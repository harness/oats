import fs from 'node:fs';
import path from 'node:path';

import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

import { importSpec } from './importSpec.mjs';
import type { ICLIConfig } from './config.mjs';
import { logError } from './helpers.mjs';

const NAME = 'oats';

yargs(hideBin(process.argv))
	.scriptName(NAME)
	.usage('Usage: $0 <cmd> [args]')
	.command(
		'import',
		'Import OpenAPI specification and output TypeScript code',
		(args) => {
			return args
				.option('file', {
					type: 'string',
					describe: 'Path to OpenAPI spec file. Can be either a JSON or YAML file.',
				})
				.option('url', {
					type: 'string',
					describe: 'URL to remote OpenAPI spec file.',
				})
				.option('output', {
					type: 'string',
					alias: 'o',
					describe: 'Location for the output.',
				})
				.option('config', {
					type: 'string',
					alias: 'c',
					describe: 'Location for the config file.',
					default: 'oats.config.ts',
				})
				.option('clean', {
					type: 'boolean',
					default: false,
					description: 'Remove the output directory before generating service.',
				})
				.option('service', {
					type: 'array',
					default: [],
					description:
						'Pick the services to generate from a config file. All the services will generated by default.',
				})
				.option('genOnlyUsed', {
					type: 'boolean',
					default: false,
					description:
						'By default, all types defined in spec are generated. Pass this flag, to only generate types, which are referenced in paths.',
				})
				.option('verbose', {
					type: 'boolean',
					describe: 'Shows verbose output',
				})
				.conflicts('file', 'url')
				.check((argv) => {
					const configFilePath = path.resolve(process.cwd(), argv.config);
					const configFileExists = fs.existsSync(configFilePath);

					if (!configFileExists && !argv.file && !argv.url) {
						throw new Error(
							`Could not resolve the config file. Either provide a config file or provide a file/url via CLI arguments.`,
						);
					}

					if ((argv.file || argv.url) && !argv.output) {
						throw new Error(`Missing required argument: output`);
					}

					return true;
				});
		},
		(argv) => {
			return importSpec(argv as ICLIConfig);
		},
	)
	.help()
	.fail((msg) => {
		if (msg) {
			logError(msg);
		}

		process.exit(1);
	})
	.demandCommand().argv;
